grammar Ziffers

  rule line
    (s / bar / repeat / multisleep / fixed_octave / numeric_octave / arpeggio / chords / pitch_classes / call / eval / rest / control / multiuse / use / slide / jumper / parens / reset / skip / escaped_opts)*
    {
      def value
        e = elements.collect {|v| v.value }.flatten.filter_map do |v|
          if v then
              v = resolve_subsets(v[:subset], v[:sleep]/v[:subset].length) if v[:subset]
              v
          end
        end
        e.flatten
      end
    }
  end

  rule escaped_opts
    '|<' s? opts:(key:([a-zA-Z0-9]+) ':' s? val:([a-zA-Z0-9:-]+) ','? s?)+ '>|'
    {
    def value
      h = Hash[*opts.elements.map {|p| [p.key.text_value.to_sym,p.val.text_value.to_i] }.flatten]
      Thread.current[:topts] = Thread.current[:topts].merge(h)
      nil
    end
    }
  end

  rule fixed_octave
    o:([\^\_]+) (s / sleep)
    {
    def value
      Thread.current[:topts][:octave] = 0 if !Thread.current[:topts][:octave]
      Thread.current[:topts][:octave] += o.text_value.split('').inject(0){|sum,x| sum + (x=='^' ? 1 : -1)}
      nil
    end
    }
  end

  rule numeric_octave
    '(' o:(integer) ')' (s / sleep)
    {
      def value
        Thread.current[:topts][:octave] = o.value
        nil
      end
    }
  end

  rule multisleep
    sleep s
    {
    def value
      Thread.current[:topts][:sleep] = sleep.value
      nil
    end
    }
  end

  rule sleep
    s:(zchar / decimal) negation:('-')? d:('.')*
    {
    def value
        sum = s.value
        sum = sum * (2.0-(1.0/(2*d.text_value.length))) if !d.text_value.empty?
        sum = s.value-(sum-s.value) if !negation.text_value.empty?
        sum
     end
    }
  end

  rule zchar
  s:([mklpdcwyhnqaefsxtgujz]+) minus:(neg_sleep)?
  {
    def value
      sum = s.text_value.split('').inject(0){|sum,x| sum + Thread.current[:default_durs][x.to_sym]}
      sum = sum-minus.value if minus.methods.include?(:value)
      sum.to_f
   end
  }
  end

  rule neg_sleep
  '-' zchar
  {
  def value
    zchar.value
  end
  }
  end

  rule arpeggio
    '@(' a:(sleep / s / group / pitch_classes)* ')'
    {
     def value
    #  chord_list = n.elements.collect {|v| v.value }.filter_map {|v| v if v}
      arp = a.elements.collect {|v| v.value }.filter_map do |v|
        if v then
          if v.is_a?(Float)
              Thread.current[:topts][:sleep] = v
              nil
          else
            v.merge!(Thread.current[:topts]) if v.is_a?(Hash)
            v
          end
        end
      end
      Thread.current[:tarp] = arp.length>0 ? arp : nil
      nil
     end
    }
  end

  rule chords
    a:(group / roman) '%'? inv:('-'? [0-9])?
    {
    def value
      c = a.value
      if !inv.text_value.empty?
        c[:chord_invert] = inv.text_value.to_i
        c[:notes] = chord_invert c[:notes], c[:chord_invert]
      end
      c[:arpeggio] = Thread.current[:tarp] if Thread.current[:tarp]
      c[:sleep] = c[:chord_sleep] if c[:chord_sleep]

      c.merge!(Thread.current[:topts]) { |key, important, default| important }
      c = ZiffHash[c]
      if !Thread.current[:tshared][:normalized]
        c = apply_transformation c, Thread.current[:tshared], 0, Thread.current[:counter]
        Thread.current[:counter] = Thread.current[:counter]+1
      end
      c
   end
   }
  end

  rule group
     pitch_classes 2..
    {
     def value
      e = elements.collect {|v| v.value }
      pitch_class_list = []
      note_list = []
      octave_list = []
      e.each do |d|
        pitch_class_list.push(d[:pc])
        note_list.push(d[:note])
        octave_list.push(d[:octave])
      end
      v = {:notes=>note_list, :pcs=>pitch_class_list, :hpcs=>e, :octaves=>octave_list}
      v.merge!(Thread.current[:topts])
      v[:amp] = e[0][:amp] if e[0][:amp]
      v[:sleep] = Thread.current[:tchordsleep] if Thread.current[:tchordsleep]
      v
     end
    }
  end

  rule roman
    roman_number:([iv]+) rd:(roman_pick)? cd:(chord_name)? '*'? oct:([0-9])?
    {
      def value
       name = Thread.current[:tshared][:chord_name].to_sym if Thread.current[:tshared][:chord_name]
       name = cd.value.to_sym if cd.methods.include?(:value)
       roman = roman_number.text_value.to_sym
        if name
          root = degree roman, Thread.current[:topts][:key], Thread.current[:topts][:scale]
          notes = chord(root, name, {num_octaves: !oct.text_value.empty? ? oct.text_value.to_i : 1}).notes
        else
          notes = chord_degree(roman, Thread.current[:topts][:key], Thread.current[:topts][:scale], rd.methods.include?(:value) ? rd.value : 3)
          # TODO: Use scale length for different scales
          scale_length = scale(Thread.current[:topts][:key], Thread.current[:topts][:scale]).length-1
          notes = notes + chord_degree(roman, (note_info Thread.current[:topts][:key]).midi_note+scale_length, Thread.current[:topts][:scale], rd.value-scale_length-1) if (rd.methods.include?(:value) && rd.value>scale_length)
          notes = notes + chord_degree(roman, (note_info Thread.current[:topts][:key]).midi_note+scale_length*2, Thread.current[:topts][:scale], rd.value-scale_length-1*2) if (rd.methods.include?(:value) && rd.value>scale_length*2)
          notes = notes + chord_degree(roman, (note_info Thread.current[:topts][:key]).midi_note+scale_length*3, Thread.current[:topts][:scale], rd.value-scale_length*3) if (rd.methods.include?(:value) && rd.value>scale_length*3)
          notes = notes + chord_degree(roman, (note_info Thread.current[:topts][:key]).midi_note+scale_length*4, Thread.current[:topts][:scale], rd.value-scale_length*4) if (rd.methods.include?(:value) && rd.value>scale_length*4)
        end
        v = {
          :roman=>roman,
          :notes=>notes.to_a
        }
        v.merge!(Thread.current[:topts])
        v[:sleep] = Thread.current[:tchordsleep] if Thread.current[:tchordsleep]
        ZiffHash[v]
      end
    }
  end

  rule roman_pick
    '+' i:([0-9]*)
    {
      def value
        i.text_value.to_i
      end
    }
  end

  rule chord_name
    '^' chord_name:([a-z-0-9+-]*)
    {
      def value
        chord_name.text_value
      end
    }
  end

  rule call
    prefix:(prefix_sleep)* m:(method_call)+
    {
      def value
        v = {methods: m.elements.collect {|v| v.value }}.merge!(Thread.current[:topts])
        prefixes = prefix.elements.map {|v| v.value}.inject{|a,b| a.merge(b){|_,x,y| x + y}}

        if prefixes
          v[:sleep] = prefixes[:sleep] if prefixes[:sleep]
        end

        ZiffHash[v]
      end
    }
  end

  rule method_call
    method_name p:(parameter_list)?
    {
      def value
      v = {
        :method => method_name.value
        }
        v[:parameters] = p.value if p.methods.include?(:value)
        v
      end
    }
  end

  rule method_name
    ':' [a-zA-Z]+
    {
      def value
        text_value
      end
    }
  end

  rule parameter_list
    '<' first:(parameter) rest:(',' i:parameter)* '>'
    {
    def value
      if rest.empty?
        first.value
      else
        r = rest.elements.map {|v| v.i.value }
        r = [first.value]+r
      end
    end
    }
  end

  rule parameter
    p:(decimal / integer)
    {
      def value
        p.value
      end
    }
  end

  rule normal_pitch_class
    d:('-'? [0-9])
    {
      def value
        d.text_value.to_i
      end
    }
  end

  rule escaped_pitch_class
    '=' '('? e:(decimal / integer) ')'?
    {
      def value
        e.value
      end
    }
  end

  rule pitch_classes
    prefix:(prefix_sleep / octave / escaped_octave / add / dynamics / staccato)* some_pitch_class:(normal_pitch_class / escaped_pitch_class)
    {
      def value
        dgr = some_pitch_class.value
        prefixes = prefix.elements.map {|v| v.value}.inject{|a,b| a.merge(b){|_,x,y| x + y}}
        prefixes = {} if !prefixes

        if !Thread.current[:topts][:midi]
          oct = prefixes[:octave] ? prefixes[:octave] : 0
          oct = oct + Thread.current[:topts][:octave] if Thread.current[:topts][:octave]
          addition = prefixes[:add] ? prefixes[:add] : 0

          v = get_ziff dgr, Thread.current[:topts][:key], Thread.current[:topts][:scale], oct, addition
        else
          v = {note: dgr, pc: note_pc(dgr), octave: note_oct(dgr), scale: :chromatic }
        end

        v.merge!(Thread.current[:topts]) { |key, important, default| important }

        v[:amp] = v[:amp] ? v[:amp]+(v[:amp]/2)*prefixes[:dynamics] : (prefixes[:dynamics]<0 ? 1.0/-(prefixes[:dynamics]-1) : 1.0+0.5*prefixes[:dynamics])  if prefixes[:dynamics]

        v[:release] = v[:release]/(prefixes[:staccato]+1) if prefixes[:staccato]

        v[:sleep] = prefixes[:sleep] if prefixes[:sleep]

        v = ZiffHash[v]
        if !Thread.current[:tshared][:normalized] # If directly from zparse
          v = apply_transformation v, Thread.current[:tshared], 0, Thread.current[:counter]+(Thread.current[:tshared][:loop_i] ? Thread.current[:tshared][:loop_i] : 0)
          Thread.current[:counter] = Thread.current[:counter]+1
        end
        v
     end
    }
  end

  rule prefix_sleep
    s:([mklpdcwyhnqaefsxtgujz]) d:('.')*
    {
    def value
        sum = Thread.current[:default_durs][s.text_value.to_sym]
        sum = sum * (2.0-(1.0/(2*d.text_value.length))) if !d.text_value.empty?
        {sleep: sum}
     end
    }
  end

  rule octave
    ('^' / '_')
    {
      def value
        {octave: (text_value=='^' ? 1 : -1) }
     end
    }
  end

  rule escaped_octave
    '(' o:(integer) ')'
    {
      def value
        {octave: o.value}
      end
    }
  end

  rule add
    ('#' / 'b')
    {
      def value
        {add: text_value=='#' ? 1 : -1}
      end
    }
  end

  rule dynamics
    ('`' / '´')
    {
      def value
        {dynamics: text_value=='´' ? 1 : -1}
      end
    }
  end

  rule staccato
    '\''
    {
      def value
        {staccato: 1}
      end
    }
  end

  rule multiuse
    use 2..
      {
      def value
        samples = elements.collect {|v| v.value }.compact
        sample_names = samples.map {|s| s[:sample]}
        chars = samples.map {|s| s[:char]}
        samples_hash = {samples: sample_names, chars: chars}
        samples_hash.merge!(samples[0].except(:sample,:char))
        samples_hash
      end
    }
  end

  rule use
    prefix:(prefix_sleep / octave / add / dynamics / staccato)* u:[A-Z]
    {
    def value
      use_list = Thread.current[:tshared][:use] if Thread.current[:tshared] and Thread.current[:tshared].has_key?(:use)
        if use_list
          prefixes = prefix.elements.map {|v| v.value}.inject{|a,b| a.merge(b){|_,x,y| x + y}}
          prefixes = {} if !prefixes

          Thread.current[:topts][:run_each] = use_list.delete(:run) if use_list[:run]
          v = use_list.has_key?(u.text_value.to_sym) ? use_list[u.text_value.to_sym].dup : nil

          return nil if !v

          if v.is_a?(Hash)
            Thread.current[:topts][:run_each] = v.delete(:run) if v[:run] and !v[:sample] and !v[:note]
            v = apply_transformation(v, v[:apply] ? v[:apply] : {apply: v.except(:sample)})
          elsif v.is_a?(Symbol)
            v = {sample: v}
          end

          v.merge!(Thread.current[:topts]) { |key, important, default| important }

          v[:sleep] = prefixes[:sleep] if prefixes[:sleep]
          v[:sleep] = 0.0 if v.has_key?(:cue)

          v[:amp] = v[:amp] ? v[:amp]+(v[:amp]/2)*prefixes[:dynamics] : (prefixes[:dynamics]<0 ? 1.0/-(prefixes[:dynamics]-1) : 1.0+0.5*prefixes[:dynamics])  if prefixes[:dynamics]

          if prefixes[:octave]
            v[:pitch] = 0.0 if !v[:pitch]
            v[:pitch] += prefixes[:octave]*12 if prefixes[:octave]
          else
            v[:pitch] = v[:pitch] ? v[:pitch]+Thread.current[:topts][:octave] : Thread.current[:topts][:octave] if Thread.current[:topts][:octave]
          end

          v[:pitch] = v[:pitch] ? v[:pitch]+Thread.current[:topts][:add] : Thread.current[:topts][:add] if prefixes[:add]

          v[:pitch_stretch] = 1.0/prefixes[:staccato] if prefixes[:staccato]

          v[:char] = u.text_value

          !(v[:sample] or v[:note] or v[:cue]) ? nil : ZiffHash[v]
        else
          nil
        end
    end
    }
  end

  rule eval
    '=(' e:(([a-zA-Z0-9] / '**' / '*' / '+' / '-' / '/' / '^' / '%' / '|' / '&' / '<<' / '>>' / '!')*) ')'
    {
      def value
        eval(e.text_value)
      end
    }
  end

  rule jumper
  ('[DC]' / '[DCF]' / '[F]' / '[S]' / '[DS]' / '[DSF]')
  {
    def value
      # TODO: Not implemented
      {
        :jumper=>text_value
      }
    end
  }
  end

  rule rest
  s:(sleep)? 'r'
  {
    def value
      v = {note: :r}
      v[:sleep] = s.methods.include?(:value) ? s.value : Thread.current[:topts][:sleep]
      ZiffHash[v]
   end
  }
  end

  rule parens
    '(' subset ')'
    {
      def value
        s = subset.elements.collect { |v| v.value }.filter_map {|v| v if v}
        {:subset=>s, :sleep=>Thread.current[:topts][:sleep]}
      end
    }
  end

  rule subset
    (s / bar / chords / pitch_classes / rest / eval / control / multiuse / use / parens / cyclic)+
    {
      def value
        elements.collect {|v| v.value }
      end
    }
  end

  rule reset
    '!'
    {
    def value
      Thread.current[:topts] = Marshal.load(Marshal.dump(Thread.current[:topts_orig]))
      nil
    end
    }
  end

  rule control
   d:([ABCDFGHIJKLMNOPQRSUWXYZ]) c:(integer / escaped_decimal / escaped_text)
   {
     def value
     control_chars = {
       'A': :amp,
       'C': :attack,
       'P': :pan,
       'D': :decay,
       'S': :sustain,
       'R': :release,
       'Z': :sleep,
       'X': :chord_sleep,
       'I': :pitch,
       'K': :key,
       'L': :scale,
       'O': :channel
     }
      control_type = control_chars[d.text_value.to_sym]
      Thread.current[:topts][control_type] = c.value if c.methods.include?(:value)
      nil
     end
    }
end

  rule decimal
    '-'? [0-9]+ '.' [0-9]+
    {
      def value
       text_value.to_f
      end
     }
  end

  rule slide
  '~' e:(escaped_decimal)? c:(chords)
    {
      def value
        v = {
          :slide=>c.value.merge!(Thread.current[:topts])
        }
        v.merge!(Thread.current[:topts])
        v[:note_slide] = e.value if e.methods.include?(:value)
        ZiffHash[v]
      end
    }
  end

  rule escaped_decimal
  '<' decimal '>'
  {
    def value
      decimal.value
    end
   }
  end

  rule escaped_text
   '<' e:([\sa-zA-Z0-9:-]*) '>'
   {
     def value
      e.text_value
     end
    }
  end

  rule repeat
   '[:' l:(repetition) ':' p:([0-9])* ']'
    {
       def value
         rep_result = []
         r = !p.text_value.empty? ? p.text_value.to_i : 2
         rep_value = l.value
         rep_value = rep_value.map {|v| (v.is_a?(Hash) and v[:subset]) ? resolve_subsets(v[:subset], v[:sleep]/v[:subset].length) : v }.flatten
         r.times do |i|
          rep = rep_value.each_with_object([]) do |v,o|
            if v.is_a?(Hash) and v[:cycle]
              o.push(v[:cycle][i%v[:cycle].length])
            else
              o.push(v)
            end
          end
          rep_result += rep
          end
         rep_result
       end
     }
  end

  rule cyclic
  '<' first:(repetition) following:(';' i:repetition)* '>'
    {
    def value
      if following.empty?
        {:cycle=>first.value}
      else
        r = following.elements.map {|v| v.i.value }
        r.prepend(first.value)
        {:cycle=>r}
      end
    end
    }
  end

  rule repetition
    (s / bar / repeat / multisleep / fixed_octave / numeric_octave / arpeggio / chords / pitch_classes / call / eval / rest / control / multiuse / use / slide / parens / reset / escaped_opts / cyclic)*
    {
      def value
        elements.collect { |v| v.value }.filter_map {|v| v if v}
      end
    }
  end

  rule integer
     '-'? [0-9]+ {
     def value
      text_value.to_i
     end }
  end

  rule s
     [\s\r\n]+
     {
     def value
      nil
    end
    }
  end

  rule skip
    '# '
    {
    def value
      Thread.current[:topts][:skip] = Thread.current[:topts][:skip] ? false : true
      nil
    end
  }
  end

  rule bar
     '|' {
       def value
          Thread.current[:topts].except!(:skip)
          Thread.current[:topts][:octave] = 0
          Thread.current[:topts][:sleep] = Thread.current[:topts_orig][:sleep] ? Thread.current[:topts_orig][:sleep] : 1.0
          Thread.current[:topts][:measure]  = !Thread.current[:topts][:measure] ? 0 : Thread.current[:topts][:measure] += 1
          nil
        end
      }
  end
end
