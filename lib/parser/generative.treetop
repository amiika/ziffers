grammar GenerativeSyntax

  rule base
    (ignore_params / set / chord_between / set_between / ranges / group / array / random_decimal / pitch_classes / rest / sleep / s / ignore)*
    {
    def value
      elements.map {|v| v.value }.flatten.filter_map {|v| ziff_to_string(v) if v}.join("")
    end
    }
  end

  rule set
    '{' ':'? content:(set_items) repeat_two:(':')? repeat:(integer)? '}' p:(('~' / '?') [1-9]*)? t:(transform)? o:(operation)*  durs:(duration_set)?
    {
    def value

      reps = repeat.value if repeat.methods.include?(:value)
      reps = (reps and reps>1) ? reps : (repeat_two.text_value==":" ? 2 : 1)

      set = reps.times.collect do |i|
        original_set = content.value.flatten.filter {|v| v != " "}

        set = Marshal.load(Marshal.dump(original_set))

        set  = set.map {|v| v = v[:cycle][i%v[:cycle].length] if v.is_a?(Hash) and v[:cycle] ; v }.flatten

        set = ZiffArray.new(set)

       # TODO: This is bit experimental
          if t.methods.include?(:value)
            t.value.split("").each do |transform|
              case transform
              when "u"
                set = set.uniq
              when "i"
                set = set.map{|v| v[:pc] = ~(v[:pc].to_i-1) if v.is_a?(Hash) ; v }
              when "m"
                set = set + set.reverse.drop(1)
              when "r"
                set = set + set.drop(1).reverse.drop(1)
              when "o"
                set = ZiffArray.new(set.ois.map{|v| {pc: v}})
              end
            end
          end

        if p and p.text_value != ""
          set = set.shuffle if p.text_value[0]=="~"
          set = p.text_value[0]=="~" ? set.take(p.text_value[1..].to_i) : set.pick(p.text_value[1..].to_i) if p.text_value.length>1
        end

        if !o.empty? then
          o.elements.each do |op|
            if op.methods.include?(:value) then
              op_values = ZiffArray.new(op.value.flatten.filter {|v| v and v != " "}) if op.value.is_a?(Array)
              case op.operator
              when '**', '*', '/', '+', '-', '^', '%', '|', '&', '<<', '>>'
                if op.value.kind_of?(Array)
                    set = op_values.map do |z|
                        set.map  do |c|
                            c_dup = Marshal.load(Marshal.dump(c))
                            z_dup = Marshal.load(Marshal.dump(z))

                            z_dup = z_dup[:cycle][i%z_dup[:cycle].length] if z_dup.is_a?(Hash) and z_dup[:cycle]

                            if z and c
                              if z.is_a?(Hash) and c.is_a?(Hash)
                                if z[:pc] and c[:pc]
                                  c_dup[:pc] = z[:pc].method(op.operator).(c[:pc])
                                elsif z[:hpcs] and c[:pc]
                                  c_dup[:hpcs] = z_dup[:hpcs].map {|h| h = Marshal.load(Marshal.dump(h)) ; h[:pc] = h[:pc].method(op.operator).(c[:pc]); h}
                                  c_dup.delete(:pc)
                                elsif c[:hpcs] and z[:pc]
                                  c_dup[:hpcs] = c[:hpcs].map {|h| h = Marshal.load(Marshal.dump(h)) ; h[:pc] = h[:pc].method(op.operator).(z[:pc]); h}
                                elsif c[:hpcs] and z[:hpcs]
                                  c_dup[:hpcs] = c_dup[:hpcs].map {|ch| z[:hpcs].map{|zh| zh = Marshal.load(Marshal.dump(zh)) ; zh[:pc] = zh[:pc].method(op.operator).(ch[:pc]) ; zh }}.flatten
                                end
                              end
                            end
                            c_dup
                        end
                      end
                    set = set.flatten

                else
                    operation_value = op.value.to_i

                    set = set.map do |v|
                      v = Marshal.load(Marshal.dump(v))
                      if v.is_a?(Hash)
                        if v[:pc]
                          v[:pc] = v[:pc].to_i.method(op.operator).(operation_value)
                        elsif v[:hpcs]
                          v[:hpcs] = v[:hpcs].map {|h| h = Marshal.load(Marshal.dump(h)) ; h[:pc] = h[:pc].method(op.operator).(operation_value); h }
                        end
                      end

                      v
                    end

                end
              when '<>'
                set = set.zip(op_values).flatten if op_values
              when '<+>'
                set = set.product(op_values).flatten if op_values
              when '<->'
                set = set-op_values if op_values
              when '<*>'
                if op_values
                set = set.ois.map do |v|
                  op_values.map do |z|
                    z = Marshal.load(Marshal.dump(z))
                    if z[:hpcs] and v.is_a?(Array)
                      z[:hpcs] = v.map {|ival| z[:hpcs].map {|h|  {pc: h[:pc]+ival} } }.flatten
                    elsif z[:pc] and v.is_a?(Array)
                        z[:hpcs] = v.map {|ival| {pc: z[:pc]+ival} }
                        z.delete(:pc)
                    elsif z[:hpcs] and v.is_a?(Integer)
                      z[:hpcs] = z[:hpcs].map {|h|  h[:pc] = h[:pc]+v ; h }

                    else
                       z[:pc] =  z[:pc]+v
                     end
                     z
                    end
                  end
                end
                set = set.flatten
              when '<&>'
                set = set&op_values if op_values
              when '<|>'
                set = set|op_values if op_values
              end
            end
          end
        end

        set.zip(Array.new(set.length-1," "))
      end

    set = set.zip(Array.new(reps," "))

    durations = durs.value if durs.methods.include?(:value)
    if durations and durations.is_a?(Array)
      set = set.flatten.map.with_index{|v,i| v[:sleep] = durations[i%durations.length] if v.is_a?(Hash) ; v  }
      set
    else
      set
    end

    end
    }
  end

  # TODO: Not in use yet - Works - but only for single sets
    rule euclid
      onbeat:(set) '<' s:([1-9]+) ',' e:([1-9]+) ','? r:([1-9]+)? '>' offbeat:(set)?
      {
      def value
        result = bin_euclid(s.text_value.to_i,e.text_value.to_i)
        .map do |n|
          if n==1
            onbeat.value
          else
            offbeat.methods.include?(:value) ? offbeat.value : "r "
          end
        end
        r.empty? ? result : result.rotate(r.text_value.to_i)
      end
      }
    end

  rule transform
    ':' type:([a-z]+)
    {
    def value
      type.text_value
    end
    }
  end

  rule duration_set
    '<' durs:(sleep / s)* '>'
    {
    def value
      durs.elements.map {|v| v.value }.filter_map {|v| v if v!=" "}
    end
    }
  end

  rule rest
    s:(sleep)? 'r'
    {
      def value
        v = {note: :r}
        v[:sleep] = s.value if s.methods.include?(:value)
        v
     end
    }
  end

  rule operation
    op:('**' / '*' / '+' / '-' / '/' / '^' / '%' / '|' / '&' / '<<' / '>>' / '<>' / '<&>' / '<->' / '<+>' / '<*>' / '<|>') val:('-'? [0-9]+ / set / array / random_between)?
    {
    def operator
      op.text_value
    end
    def value
     if val.methods.include?(:value)
        v = val.value
        v
      else
        val.text_value
      end
    end
    }
  end

  rule array
    '[' first:(array_items) rest:(',' i:array_items)+ ']'
    {
    def value
      if rest.empty?
        first.value
      else
        r = rest.elements.map {|v| v.i.value }
        r.append(first.value).pick.flatten
      end
    end
    }
  end

  rule set_items
    (set / ranges / group / pitch_classes / rest / s / sleep / array / set_between / control / cyclic / bar)*
    {
    def value
      elements.map {|v| v.value }.filter_map {|v| v if v}
    end
    }
  end

  rule cyclic
  '<' first:(set_items) following:(';' i:set_items)* '>'
    {
    def value
      if following.empty?
        {:cycle=>first.value}
      else
        r = following.elements.map {|v| v.i.value }
        r.prepend(first.value)
        {:cycle=>r}
      end
    end
    }
  end

  rule array_items
    (set / ranges / group / pitch_classes / rest / s / sleep / array / random_between / method / control / bar)*
    {
    def value
      elements.map {|v| v.value }.filter_map {|v| v if v}
    end
    }
  end

  rule method
    ':' [a-zA-Z]+ ('<' [0-9\.\,]* '>')?
    {
      def value
        text_value
      end
    }
  end

  rule control
    [A-Z]
    {
      def value
        text_value
      end
    }
  end

  # Characters ignored by generative parsing and parsed using ziffers parser
  rule ignore
   ([!\~&@|{}<>\[\]():;#\^_%\n\-\/\*\+\.`Â´\,\'] / [a-zA-Z0-9])
    {
      def value
        text_value
      end
    }
  end

  rule ignore_params
    '<=' (([a-zA-Z0-9])+ ':' s? ([a-zA-Z0-9:-])+ ','? s?)+ '=>'
    {
      def value
        text_value
      end
    }
  end

  rule anything
    [\s\S]+
    {
      def value
        text_value
      end
    }
  end

  rule s
      [\s\r\n]+
      {
        def value
          " "
        end
      }
  end

  rule group
   pitch_classes 2..
    {
     def value
     e = elements.collect {|v| v.value }
      if Thread.current[:parse_chords]
        pitch_class_list = []
        e.each do |d|
          pitch_class_list.push(d[:pc])
        end
        v = {:hpcs=>e}
        ZiffHash[v]
      else
        e.zip(Array.new(e.length-1," "))
      end
     end
    }
  end

  rule normal_pitch_class
    d:('-'? [0-9TE])
    {
      def value
        parse_str_dgr(d.text_value)
      end
    }
  end

  # Not in use
  rule escaped_eval
    '=(' e:(([a-zA-Z0-9] / '**' / '*' / '+' / '-' / '/' / '^' / '%' / '|' / '&' / '<<' / '>>' / '!')*) ')'
    {
      def value
        eval(e.text_value)
      end
    }
  end

  rule random_pitch_class
    '?'
    {
      def value
        SonicPi::Core::SPRand.rand_i!(11)
      end
    }
  end

  rule random_decimal
    '(' m:(decimal) ',' x:(decimal) ')'
      {
        def value
          sonic_random_float(m.value,x.value)
        end
      }
  end

  rule decimal
    '-'? [0-9]* '.' [0-9]+
    {
      def value
       text_value.to_f
      end
     }
  end

  rule integer
    '-'? [0-9]+
    {
      def value
        text_value.to_i
      end
    }
  end

  rule set_between
    '(' m:(min_max) ':' x:(min_max) ')'
    {
      def value
        sonic_random(m.value,x.value).to_s.split("")
      end
    }
  end

  rule chord_between
    '(' m:(min_max) ';' x:(min_max) ')'
    {
      def value
        arr = sonic_random(m.value,x.value).to_s.split("")
        arr = arr.zip(Array.new(arr.length," "))
        arr
      end
    }
  end

  rule random_between
  '(' m:(min_max) ',' x:(min_max) ')'
    {
      def value
        sonic_random(m.value,x.value)
      end
    }
  end

  rule min_max
    v:(integer / integer_array / random_between)
    {
      def value
        v.value
      end
    }
  end

  rule ranges
    v:(normal_ranges / set_ranges / chord_ranges)
    {
      def value
        v.value
      end
    }
  end

  rule set_ranges
   a:(min_max) ';;' b:(min_max) c:(step?)
   {
   def value
     step = c.value if c.methods.include?(:value)
     type = c.type if c.methods.include?(:type)
     arr = sonic_range(a.value.to_i,b.value.to_i,step,type)
     arr = arr.map {|v| v.to_s.split("") }.flatten
     arr.each_with_object([]){|v,o| o.push({pc: v.to_i}) ; o.push(" ") }
   end
   }
  end

  rule chord_ranges
   a:(min_max) '::' b:(min_max) c:(step?)
   {
   def value
     step = c.value if c.methods.include?(:value)
     type = c.type if c.methods.include?(:type)
     arr = sonic_range(a.value.to_i,b.value.to_i,step,type)
     arr.each_with_object([]){|v,o| o.push({pc: v.to_i}) ; o.push(" ") }
   end
   }
  end

  rule normal_ranges
   a:(min_max) '..' b:(min_max) c:(step?)
   {
   def value
     step = c.value if c.methods.include?(:value)
     type = c.type if c.methods.include?(:type)
     arr = sonic_range(a.value.to_i,b.value.to_i,step,type)
     arr.each_with_object([]){|v,o| o.push({pc: v}) ; o.push(" ") }
   end
   }
  end

  rule step
    op:('+' / '*') min_max
    {
      def type
        op.text_value
      end
      def value
        min_max.value
      end
    }
  end

  rule integer_array
    '[' first:(min_max) rest:(',' i:(min_max))* ']'
    {
    def value
      if rest.empty?
        first.value
      else
        r = rest.elements.map {|v| v.i.value }
        [r].append([first.value].flatten).flatten.pick(1)[0]
      end
    end
    }
  end

  rule pitch_classes
   z:(sleep)* o:('^' / '_')* a:('#' / 'b')* d:(normal_pitch_class / escaped_eval / random_pitch_class / random_between)
    {
     def value
       dgr = d.value
       v = {:pc=>dgr}
       v[:add] = a.text_value if !a.text_value.empty?
       v[:octave] = o.text_value if !o.text_value.empty?
       v[:sleep] = z.text_value  if !z.text_value.empty?
       ZiffHash[v]
     end
    }
  end

  rule bar
     '|' {
      def value
       text_value
     end
     }
   end

  rule sleep
    [mklpdcwyhnqaefsxtgujz] ('.')*
    {
    def value
      text_value
    end
    }
  end

end
