grammar GenerativeSyntax

  rule base
    (enclosed_set / ignore /  assign_set / control / use / escaped_multi_octave / repeat / set / conditional_assingment / ranges / decimal_sleep / roman / group  / random_decimal / multi_escape / eval / pitch_classes / array / multisleep / multioctave / rest /  s / bar / parens / random_percent)*
    {
      def value
        e = elements.collect {|v| v.value }.map do |v|
          if v.is_a?(Hash) then
            if v[:subset]
              v = resolve_subsets(v[:subset], v[:subsleep]/v[:subset].length)
              v.map {|h| h.to_z }.join(" ")
            elsif v[:cycle]
              cycle = v[:cycle][Thread.current[:tshared][:loop_i]%v[:cycle].length].to_z
            else
              v.to_z
            end
          elsif v.is_a?(Array)
            v.flatten.map {|v| v.is_a?(Hash) ? (v[:subset] ? resolve_subsets(v[:subset], v[:subsleep]/v[:subset].length).map {|h| h.to_z }.join(" ") : v.to_z) : v}
          else
           v.to_s
          end
        end
        e.reject {|e| e.to_s.empty? }.join(" ")
      end
    }
  end

  rule enclosed_set
    p:(ignore_params / set_sleep) s:(set)
    {
      def value
        val = s.value
        if val.is_a?(Array)
          p.value+"("+val.flatten.map {|v| v.is_a?(Hash) ? (v[:subset] ? resolve_subsets(v[:subset], v[:subsleep]/v[:subset].length).map {|h| h.to_z }.join(" ") : v.to_z) : v}.join(" ")+")"
        else
          p.value+(val.is_a?(Hash) ? val.to_z : v)
        end
      end
    }
  end

  rule set_sleep
    [a-z]+
    {
    def value
      text_value
    end
    }
  end

  rule set
    durs:(duration_set)? '(' ':'? content:(set_items) repeat_two:(':')? repeat_times:(integer)? ')' p:(('~' / '?' / '#') [1-9]*)? t:(transform)? a:(array_method)? o:(operation)* eval_f:(ternary)?
    {
    def value

      reps = repeat_times.value if repeat_times.methods.include?(:value)
      reps = (reps and reps>1) ? reps : (repeat_two.text_value==":" ? 2 : 1)

      set = reps.times.collect do |i|
        original_set = content.value.flatten

        set = Marshal.load(Marshal.dump(original_set))

        set  = set.map {|v| v = v[:cycle][i%v[:cycle].length] if v.is_a?(Hash) and v[:cycle] ; v }.flatten.compact

        set = ZiffArray.new(set)

        # TODO: Early prototype of method calling
        if a.methods.include?(:value)
          method_call = a.value
          if method_call[1]
            set = set.method(method_call[0]).(*method_call[1])
          else
            set = set.method(method_call[0]).()
          end
        end

        # TODO: Replace this with aliased array methods?
        if t.methods.include?(:value)
          t.value.split("").each do |transform|
            case transform
            when "!"
              set = set.compact.uniq
            when "@"
              set = set + set.compact.drop(1).reverse.drop(1) if set.length>2
            when "$"
              set = set.compact.map{|v| (v[:hpcs] ? v[:hpcs].map{|h| h[:pc]} : v[:pc].to_s.split("")).map{|d| ZiffHash[{pc: d.to_i}] } }.flatten
            when "&"
              set = set.compact.map do |v|
                if !v[:hpcs]
                  v[:hpcs] = v[:pc].to_s.split("").map{|i| ZiffHash[{pc: i.to_i }] }
                  v.delete(:pc)
                end
                v
              end
            end
          end
        end

        if p and p.text_value != ""
          set = set.shuffle if p.text_value[0]=="~"
          set = p.text_value[0]=="~" ? set.take(p.text_value[1..].to_i) : set.pick(p.text_value[1..].to_i) if p.text_value.length>1
        end

        if !o.empty? then
          o.elements.each do |op|
            if op.methods.include?(:value) then
              op_values = ZiffArray.new(op.value.flatten) if op.value.is_a?(Array)
              case op.operator
              when '**', '*', '/', '+', '-', '^', '%', '|', '&', '<<', '>>'
                if op.value.kind_of?(Array)
                    set = op_values.map do |z|
                        set.map  do |c|
                            c_dup = Marshal.load(Marshal.dump(c))
                            z_dup = Marshal.load(Marshal.dump(z))

                            z_dup = z_dup[:cycle][i%z_dup[:cycle].length] if z_dup.is_a?(Hash) and z_dup[:cycle]

                            if z and c
                              if z.is_a?(Hash) and c.is_a?(Hash)
                                if z[:pc] and c[:pc]
                                  c_dup[:pc] = z[:pc].method(op.operator).(c[:pc])
                                elsif z[:hpcs] and c[:pc]
                                  c_dup[:hpcs] = z_dup[:hpcs].map {|h| h = Marshal.load(Marshal.dump(h)) ; h[:pc] = h[:pc].method(op.operator).(c[:pc]); h}
                                  c_dup.delete(:pc)
                                elsif c[:hpcs] and z[:pc]
                                  c_dup[:hpcs] = c[:hpcs].map {|h| h = Marshal.load(Marshal.dump(h)) ; h[:pc] = h[:pc].method(op.operator).(z[:pc]); h}
                                elsif c[:hpcs] and z[:hpcs]
                                  c_dup[:hpcs] = c_dup[:hpcs].map {|ch| z[:hpcs].map{|zh| zh = Marshal.load(Marshal.dump(zh)) ; zh[:pc] = zh[:pc].method(op.operator).(ch[:pc]) ; zh }}.flatten
                                end
                              end
                            end
                            c_dup
                        end
                      end
                    set = set.flatten

                else
                    operation_value = op.value.to_i

                    set = set.map do |v|
                      v = Marshal.load(Marshal.dump(v))
                      if v.is_a?(Hash)
                        if v[:pc]
                          v[:pc] = v[:pc].to_i.method(op.operator).(operation_value)
                        elsif v[:hpcs]
                          v[:hpcs] = v[:hpcs].map {|h| h = Marshal.load(Marshal.dump(h)) ; h[:pc] = h[:pc].method(op.operator).(operation_value); h }
                        end
                      end
                      v
                    end

                end
              when '<>'
                set = set.zip(op_values).flatten if op_values
              when '<+>'
                set = set.product(op_values).flatten if op_values
              when '<->'
                set = set-op_values if op_values
              when '<*>'
                if op_values
                set = set.ois.map do |v|
                  op_values.map do |z|
                    z = Marshal.load(Marshal.dump(z))
                    if z[:hpcs] and v.is_a?(Array)
                      z[:hpcs] = v.map {|ival| z[:hpcs].map {|h|  ZiffHash[{pc: h[:pc]+ival}] }}.flatten
                    elsif z[:pc] and v.is_a?(Array)
                        z[:hpcs] = v.map {|ival| ZiffHash[{pc: z[:pc]+ival}] }
                        z.delete(:pc)
                    elsif z[:hpcs] and v.is_a?(Integer)
                      z[:hpcs] = z[:hpcs].map {|h|  h[:pc] = h[:pc]+v ; h }
                    else
                       z[:pc] =  z[:pc]+v
                     end
                     z
                    end
                  end
                end
                set = set.flatten
              when '<&>'
                set = set&op_values if op_values
              when '<|>'
                set = set|op_values if op_values
              end
            end
          end
        end

        if eval_f.methods.include?(:value)
          tfunc = eval_f.value
          set = set.compact.map do |v|
            if v.is_a?(Hash)
              if v[:pc]
                v[:pc] = eval_func(v[:pc],tfunc)
              elsif v[:hpcs]
                v[:hpcs] = v[:hpcs].map do |h|
                  h[:pc] = eval_func(h[:pc],tfunc)
                end
                v
              end
            end
            v
          end
        end
        set
      end

    durations = durs.value if durs.methods.include?(:value)
    if durations and durations.is_a?(Array)
      set = set.flatten.map.with_index{|v,i| v[:sleep] = durations[i%durations.length] if v.is_a?(Hash) ; v  }
      set
    else
      set
    end

    end
    def eval_func(v,tfunc)
      if tfunc.is_a?(Array)
        cond = eval tfunc[0].gsub("x",v.to_s)
        if cond
          eval_func v, tfunc[1]
        else
          eval_func v, tfunc[2]
        end
      else
        eval tfunc.gsub("x",v.to_s)
      end
    end
    }
  end

  # TODO: Not in use yet - Works - but only for single sets
    rule euclid
      onbeat:(set) '<' s:([1-9]+) ',' e:([1-9]+) ','? r:([1-9]+)? '>' offbeat:(set)?
      {
      def value
        result = bin_euclid(s.text_value.to_i,e.text_value.to_i)
        .map do |n|
          if n==1
            onbeat.value
          else
            offbeat.methods.include?(:value) ? offbeat.value : "r "
          end
        end
        r.empty? ? result : result.rotate(r.text_value.to_i)
      end
      }
    end

    rule array_method
      '.' v:([a-z_]+) i:('(' r:([\-0-9,]+) ')')?
      {
      def value
        [v.text_value,(i.empty?) ? nil : i.r.text_value.split(",").map {|v| v.to_i}]
      end
      }
    end

  rule transform
    [\!\$\@\&]+
    {
    def value
      text_value
    end
    }
  end

  rule assign_set
    k:([ABCDFGHIJKLMNOPQRSUWXYZO]) '=' set
    {
      def value
        Thread.current[:tshared][:use] = {} if !Thread.current[:tshared][:use]
        Thread.current[:tshared][:use][k.text_value] = set.value.flatten.map {|v| v.is_a?(Hash) ? (v[:subset] ? resolve_subsets(v[:subset], v[:subsleep]/v[:subset].length).map {|h| h.to_z }.join(" ") : v.to_z) : v}
        nil
      end
    }
  end

    rule use
      prefix:(prefix_list)? k:([ABCDFGHIJKLMNOPQRSUWXYZO]+)
      {
        def value
        prefixes = prefix.value.flatten.inject{|a,b| a.merge(b){|_,x,y| x + y}} if prefix.methods.include?(:value)
        prefixes = {} if !prefixes

          use_val = k.text_value

          if use_val.length==1 and Thread.current[:tshared][:use] and Thread.current[:tshared][:use][use_val]
            Thread.current[:tshared][:use][use_val]
          else
            v = {char: k.text_value}
            v[:prefix] = prefixes[:prefix] if prefixes[:prefix]
            v[:sleep] = prefixes[:sleep] if prefixes[:sleep]
            ZiffHash[v]
          end
        end
      }
    end

  rule duration_set
    '<' durs:(sleep / s)* '>'
    {
    def value
      durs.elements.map {|v| v.value }.compact
    end
    }
  end

  rule rest
    s:(sleep)? 'r'
    {
      def value
        v = ZiffHash[{note: :r}]
        v[:subsleep] = s.value if s.methods.include?(:value)
        v
     end
    }
  end

  rule operation
    op:('**' / '*' / '+' / '-' / '/' / '^' / '%' / '|' / '&' / '<<' / '>>' / '<@>' / '<>' / '<&>' / '<->' / '<+>' / '<*>' / '<|>') val:('-'? [0-9]+ / set / array / random_between)?
    {
    def operator
      op.text_value
    end
    def value
     if val.methods.include?(:value)
        v = val.value
        v
      else
        val.text_value
      end
    end
    }
  end

  rule parens
    '[' parens_subset ']'
    {
      def value
        s = parens_subset.elements.collect { |v| v.value }.filter_map {|v| v if v.is_a?(Hash)}
        {:subset=>s, :subsleep=>Thread.current[:topts][:sleep]}
      end
    }
  end

  rule repeat
   '[:' l:(repeat_subset) ':' p:([0-9])* ']'
    {
       def value
         rep_result = []
         r = !p.text_value.empty? ? p.text_value.to_i : 2
         rep_value = l.value
         rep_value = rep_value.map {|v| (v.is_a?(Hash) and v[:subset]) ? resolve_subsets(v[:subset], v[:subsleep]/v[:subset].length) : v }
         # TODO: Check default sleep in some cases like: [: 2 0.25 3 :] ?
         r.times do |i|
          rep = rep_value.each_with_object([]) do |v,o|
            if v.is_a?(Hash) and v[:cycle]
              o.push(v[:cycle][i%v[:cycle].length])
            else
              o.push(v)
            end
          end
          rep_result += rep
          end
         rep_result.flatten.compact
       end
     }
  end

  rule array
    '[' first:(array_subset) rest:(',' i:array_subset)+ ']'
    {
    def value
      if rest.empty?
        first.value
      else
        r = rest.elements.map {|v| v.i.value }
        r.append(first.value).pick.flatten
      end
    end
    }
  end

  rule set_items
    (ignore / ranges / repeat / use / control / escaped_multi_octave / decimal_sleep / group / roman / cyclic / eval / pitch_classes / multisleep / multioctave / rest / s / array / random_between / conditional_assingment / parens / bar / set)*
    {
    def value
      elements.map {|v| v.value }
    end
    }
  end

  rule repeat_subset
    (ignore / ranges / repeat / use / control / escaped_multi_octave / decimal_sleep / group / roman / cyclic / eval / pitch_classes / multisleep / multioctave / rest / s / array / random_between / conditional_assingment / parens / bar)*
    {
    def value
      elements.map {|v| v.methods.include?(:exact_value) ? v.exact_value : v.value }
    end
    }
  end

  rule cyclic_subset
    (ignore / ranges / repeat / use / control / escaped_multi_octave / decimal_sleep / group / roman / eval / pitch_classes / multisleep / multioctave / rest / s / array / random_between / conditional_assingment / parens  / bar)*
    {
    def value
      elements.map {|v| v.value }
    end
    }
  end

  rule array_subset
    (ignore / use / control / ranges / escaped_multi_octave / decimal_sleep / group / roman / eval / pitch_classes / multisleep / multioctave / rest / s / array / random_between / conditional_assingment / parens / bar)*
    {
    def value
      elements.map {|v| v.value }
    end
    }
  end

  rule parens_subset
    (ignore / use / control / ranges / escaped_multi_octave / group / roman / eval / pitch_classes / multioctave / rest / s / random_between / parens)*
    {
    def value
      elements.map {|v| v.value }
    end
    }
  end

  rule cyclic
  '<' first:(cyclic_subset) following:(';' i:cyclic_subset)+ '>'
    {
    def value
      if following.empty?
        {:cycle=>first.value}
      else
        r = following.elements.map {|v| v.i.value }
        r.prepend(first.value)
        {:cycle=>r}
      end
    end
    }
  end

  rule function_call
    func:([a-z]* '{' [a-zA-Z]+) function_params? '}'
    {
      def value
        func.text_value + (function_params.empty? ? "" : function_params.value)
      end
    }
  end

  rule function_params
    '(' val:(decimal / integer / random_between / ',')* ')'
    {
      def value
        val.elements.map {|v| v.methods.include?(:value) ? v.value : v.text_value }.join("")
      end
    }
  end

  rule control
    c:([A-Z]) v:(escaped_random / integer / escaped_decimal / escaped_text)
    {
      def value
        c.text_value+v.value.to_s
      end
    }
  end

  rule escaped_random
    '<' v:(random_between / random_decimal) '>'
    {
      def value
        "<"+v.value.to_s+">"
      end
    }
  end

  rule escaped_decimal
  '<' decimal '>'
  {
    def value
      text_value
    end
   }
  end

  rule escaped_text
   '<' e:([\sa-zA-Z0-9:\-]*) '>'
   {
     def value
      text_value
     end
    }
  end

  # Characters ignored by generative parsing and parsed using ziffers parser
  rule ignore
    v:(reset  / slide / arpeggio / ignore_function / ignore_comment / ignore_params)
    {
      def value
        v.value.to_s
      end
    }
  end

  rule reset
    "!"
    {
      def value
        text_value
      end
    }
  end

  rule arpeggio
    '@(' ([a-z] / [0-9ET] / s )+ ')'
    {
      def value
        text_value
      end
    }
  end

  rule multioctave
    o:('^' / '_')+ s
    {
      def value
        o.text_value
      end
      def exact_value
        "<"+o.elements.map {|v| (v.text_value=='^' ? 1 : -1)}.inject(0,:+).to_s+">"
     end
    }
  end

  rule ignore_params
    '{' (([a-zA-Z0-9])+ ':' s? ([a-zA-Z0-9\-\.])+ ','? s?)+ '}'
    {
      def value
        text_value
      end
    }
  end

  rule ignore_function
    ':' [a-zA-Z]+ [a-zA-Z0-9_]* ('(' [a-zA-Z0-9\,\s\.]* ')')?
    {
      def value
        text_value
      end
    }
  end

  rule ignore_comment
    '<!' [a-zA-Z0-9_\-\s\n\r\|#+\-*]+ '>'
    {
      def value
        text_value
      end
    }
  end

  rule anything
    [\s\S]+
    {
      def value
        nil
      end
    }
  end

  rule s
      [\s\r\n]+
      {
        def value
          nil
        end
      }
  end

  rule roman_number
    [iv]+
  end

  rule roman
    roman_number rd:(roman_pick)? cd:(chord_name)? '*'? oct:([0-9])? inv:(inverse)?
    {
      def value
       name = Thread.current[:tshared][:chord_name].to_sym if Thread.current[:tshared][:chord_name]
       name = cd.value.to_sym if cd.methods.include?(:value)
       roman = roman_number.text_value.to_sym
        if name
          root = degree roman, Thread.current[:topts][:key], Thread.current[:topts][:scale]
          shift = note_info(Thread.current[:topts][:key]).midi_note-60
          notes = chord(root, name, {num_octaves: !oct.text_value.empty? ? oct.text_value.to_i : 1}).notes
          pcs = notes.map {|n| midi_to_pc(n-shift,Thread.current[:topts][:key], Thread.current[:topts][:scale]) }
          pcs
        else
          pc_scale = (scale 0, Thread.current[:topts][:scale], num_octaves: 7).notes.to_a
          trichords = (Scale.from_roman(roman)-1).step(pc_scale.size-1,2).map {|i| pc_scale[i]} # Select every 2nd
          take_notes = (rd.methods.include?(:value) ? rd.value : 3)
          take_notes = take_notes * oct.text_value.to_i if !oct.text_value.empty?
          chrom_pcs = trichords.take(take_notes)
          pcs = chrom_pcs.map {|idx| pc_scale.index(idx) }
          pcs = pcs.map {|p| get_ziff(p,Thread.current[:topts][:key], Thread.current[:topts][:scale]) }
        end
        v = {
          :roman=>roman,
          :hpcs=>pcs,
          :key=>Thread.current[:topts][:key],
          :scale=>Thread.current[:topts][:scale]
        }
        v.merge!(Thread.current[:topts])
        v[:subsleep] = Thread.current[:tchordsleep] if Thread.current[:tchordsleep]
        parsed_chord = ZiffHash[v]
        parsed_chord.inv_chord! inv.value if inv.methods.include?(:value)
        parsed_chord
      end
    }
  end

  rule roman_pick
    '+' i:([0-9]*)
    {
      def value
        i.text_value.to_i
      end
    }
  end

  rule chord_name
    '^' chord_name:([a-z0-9\+\-]+)
    {
      def value
        chord_name.text_value
      end
    }
  end

  rule inverse
    '%' inv:('-'? [0-9])
    {
      def value
        inv.text_value.to_i
      end
    }
  end

  rule group
    p:(pitch_classes) 2.. inv:(inverse)?
    {
     def value
     e = p.elements.collect {|v| v.value }
      if Thread.current[:tshared][:parse_chords]==nil or Thread.current[:tshared][:parse_chords]
        c = ZiffHash[{hpcs: e, key: e[0][:key], scale: e[0][:scale]}]
        c.inv_chord! inv.value if inv.methods.include?(:value)
        c
      else
        e
      end
     end
    }
  end

  rule normal_pitch_class
    d:('-'? [0-9TE])
    {
      def value
        parse_str_dgr(d.text_value)
      end
    }
  end

  rule multi_escape
    '{' e:((random_decimal / random_between / decimal / integer / ' ')*) '}'
    {
      def value
        e.elements.map {|v| v.text_value.strip.empty? ? v.text_value : "{"+(v.value || v.text_value).to_s+"}" }.join("")
      end
    }
  end

  rule escaped_eval
    '{' e:((random_decimal / random_between / decimal / integer / '**' / '*' / '+' / '-' / '/' / '^' / '%' / '|' / '&' / '<<' / '>>' / '!' / '~')*) '}'
    {
      def value
        v = e.elements.map {|v| v.methods.include?(:value) ? v.value : v.text_value }.join("")
        eval(v)
      end
    }
  end

  rule eval
    '={' e:((random_decimal / random_between / decimal / integer / '**' / '*' / '+' / '-' / '/' / '^' / '%' / '|' / '&' / '<<' / '>>' / '!' / '~')*) '}'
    {
      def value
        v = e.elements.map {|v| v.methods.include?(:value) ? v.value : v.text_value }.join("")
        eval(v)
      end
    }
  end

  rule random_pitch_class
    '?'
    {
      def value
        SonicPi::Core::SPRand.rand_i!(Thread.current[:topts][:scale] ? (scale 0, Thread.current[:topts][:scale]).length : 9)
      end
    }
  end

  rule random_percent
    '%'
      {
        def value
          sonic_random_float(0,1,3)
        end
      }
  end

  rule random_decimal
    '(' m:(decimal) ',' x:(decimal) ')'
      {
        def value
          sonic_random_float(m.value,x.value)
        end
      }
  end

  rule decimal
    '-'? [0-9]* '.' [0-9]+
    {
      def value
       text_value.to_f
      end
     }
  end

  rule integer
    '-'? [0-9]+
    {
      def value
        text_value.to_i
      end
    }
  end

  rule min_max
    v:(integer / integer_array / random_between)
    {
      def value
        v.value
      end
    }
  end

  rule ranges
   a:(min_max) '..' b:(min_max) c:(step?)
   {
   def value
     step = c.value if c.methods.include?(:value)
     type = c.type if c.methods.include?(:type)
     arr = sonic_range(a.value.to_i,b.value.to_i,step,type)
     arr = arr.map {|v| ZiffHash[{pc: v}] }
     ZiffArray[arr]
   end
   }
  end

  rule random_between
  '(' m:(min_max) ',' x:(min_max) ')'
  {
    def value
      sonic_random(m.value,x.value)
    end
    def text_value
      self.value.to_s
    end
  }
end

rule conditional_assingment
  '{' conditional_set '}'
  {
    def value
      eval_cond conditional_set.value
    end
    def eval_cond(tfunc)
      if tfunc.is_a?(Hash)
        cond = eval tfunc[:condition]
        if cond
          eval_cond tfunc[:if]
        else
          eval_cond tfunc[:else]
        end
      else
        tfunc
      end
    end
  }
end

rule conditional_set
  cond:(condition) s? '?' s? first:(conditional_assingment / set / set_items) s? ':'? s? second:(conditional_assingment / set / set_items)?
  {
    def value
      {
      :condition => (cond.methods.include?(:value) ? cond.value : nil),
      :if => (first.methods.include?(:value) ? first.value : nil),
      :else => (second.methods.include?(:value) ? second.value : nil)
      }
    end
  }
end

  rule ternary
  '{' t:(conditional / clause) '}'
    {
      def value
        t.value
      end
    }
  end

  rule conditional
    cond:(condition) s? '?' s? first:(ternary / clause) s? ':'? s? second:(ternary / clause)?
    {
      def value
        a = [(cond.methods.include?(:value) ? cond.value : nil), (first.methods.include?(:value) ? first.value : nil), (second.methods.include?(:value) ? second.value : nil)]
        a
      end
    }
  end

  rule condition
    (clause) comparison (clause)
    {
      def value
        elements.map {|v| v.methods.include?(:value) ? v.value : v.text_value }.flatten.compact.join("")
      end
    }
  end

  rule comparison
    ([<>!=] [=] 0..1)
    {
      def value
        text_value
      end
    }
  end

  rule clause
    first:(decimal / random_percent / mult_term / integer / integer_array / random_between / escaped_clause) rest:(op:operator cl:(decimal / random_percent / mult_term / integer / integer_array / random_between / escaped_clause))*
    {
      def value
        if rest.empty?
          first.value.to_s
        else
          r = rest.elements.map {|v| v.op.value+v.cl.value.to_s }
          first.value.to_s+r.flatten.reject {|e| e.to_s.empty? }.join("")
        end
      end
    }
  end

  rule escaped_clause
    '(' clause ')'
    {
      def value
      "("+clause.value.to_s+")"
    end
    }
  end

  rule mult_term
    a:(integer / integer_array / random_between)? b:('x')
    {
      def value
        ret = a.methods.include?(:value) ? a.value.to_s+"*"+b.text_value : b.text_value
        ret
      end
    }
  end

  rule operator
    op:('**' / '*' / '+' / '-' / '/' / '^' / '%' / '|' / '&' / '<<' / '>>' / ')(')
    {
      def value
        op.text_value==")(" ? ")*(" : text_value
      end
    }
  end

  rule step
    op:('+' / [*] 1..2) min_max
    {
      def type
        op.text_value
      end
      def value
        val = min_max.value
        val+=1 if val==0
        val
      end
    }
  end

  rule integer_array
    '[' first:(min_max) rest:(',' i:(min_max))+ ']'
    {
    def value
      if rest.empty?
        first.value
      else
        r = rest.elements.map {|v| v.i.value }
        [r].append([first.value].flatten).flatten.pick(1)[0]
      end
    end
    }
  end

  rule pitch_classes
    prefix:(prefix_list)? d:(normal_pitch_class / escaped_eval / random_pitch_class / random_between)
    {
      def value
        prefixes = prefix.value.flatten.inject{|a,b| a.merge(b){|_,x,y| x + y}} if prefix.methods.include?(:value)
        prefixes = {} if !prefixes

        dgr = d.value
        v = {:pc=>dgr, :key=>Thread.current[:topts][:key], :scale=>Thread.current[:topts][:scale]}

        v[:prefix] = prefixes[:prefix] if prefixes[:prefix]
        v[:subsleep] = Thread.current[:topts][:sleep] if Thread.current[:topts][:sleep]

        if prefixes[:sleep]
          v[:sleep] = Thread.current[:topts][:sleep] if Thread.current[:topts][:sleep]
          v[:sleep] = prefixes[:sleep]
        end
        ZiffHash[v]
     end
    }
  end

  rule prefix_list
    (prefix_array / escaped_prefix_sleep / prefix_octave / prefix_sleep / octave / escaped_octave / add / dynamics / staccato)*
    {
    def value
      elements.map {|v| v.value }
    end
    }
  end

  rule prefix_array
    '[' first:(prefix_list) rest:(',' i:(prefix_list))+ ']'
    {
    def value
      if rest.empty?
        first.value
      else
        r = rest.elements.map {|v| v.i.value }
        r.append(first.value).pick.flatten
      end
    end
    }
  end

  rule prefix_sleep
    s:([mklpdcwyhnqaefsxtgujz]) d:('.')*
    {
    def value
        sum = Thread.current[:default_durs][s.text_value.to_sym]
        sum = sum * (2.0-(1.0/(2*d.text_value.length))) if !d.text_value.empty?
        {sleep: sum}
     end
    }
  end

  rule escaped_prefix_sleep
  '[' decimal ']'
  {
    def value
      {sleep: decimal.value}
    end
   }
  end

  rule prefix_octave
    o:('^' / '_')+
    {
      def value
        {prefix: o.text_value }
      end
      def exact_value
        {prefix: "<"+o.elements.map {|v| (v.text_value=='^' ? 1 : -1)}.inject(0,:+).to_s+">" }
     end
    }
  end

  rule slide
    '~' v:(escaped_random / escaped_decimal)?
    {
      def value
        "~" + (v.methods.include?(:value) ? v.value.to_s : "")
     end
    }
  end

  rule escaped_octave
    '<' o:(integer) '>'
    {
      def value
        {prefix: text_value}
      end
    }
  end

  rule escaped_multi_octave
    o:('<' integer '>') s
    {
      def value
        o.text_value
      end
    }
  end

  rule add
    ('#' / 'b')
    {
      def value
        {prefix: text_value}
      end
    }
  end

  rule dynamics
    ('`' / 'Â´')
    {
      def value
        {prefix: text_value}
      end
    }
  end

  rule staccato
    '\''
    {
      def value
        {prefix: text_value}
      end
    }
  end

  rule bar
     '|' {
      def value
       text_value
     end
     }
   end

   rule multisleep
     s:(sleep)
     {
     def value
       Thread.current[:topts][:sleep] = s.value
       s.text_value
     end
     }
   end

   rule sleep
     s:(zchar) d:('.')*
     {
     def value
         sum = s.value
         sum = sum * (2.0-(1.0/(2*d.text_value.length))) if !d.text_value.empty?
         sum
      end
     }
   end

   rule decimal_sleep
     s:(decimal)
     {
     def value
         s.value
      end
     }
   end

   rule zchar
   s:([mklpdcwyhnqaefsxtgujz]+)
   {
     def value
       sum = s.text_value.split('').inject(0){|sum,x| sum + Thread.current[:default_durs][x.to_sym]}
       sum.to_f
    end
   }
   end

end
